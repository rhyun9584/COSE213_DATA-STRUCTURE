#include <stdlib.h> // malloc#include <stdio.h>#include <ctype.h> // toupper#define QUIT	1#define INSERT	2#define DELETE	3#define PRINT	4#define SEARCH	5////////////////////////////////////////////////////////////////////////////////// LIST type definitiontypedef struct node{	int			data;	struct node	*link;} NODE;typedef struct{	int		count;	NODE	*pos;	NODE	*head;	NODE	*rear;} LIST;////////////////////////////////////////////////////////////////////////////////// Prototype declarationsstatic int _insert(LIST* pList, NODE* pPre, int dataIn);static void _delete(LIST *pList, NODE *pPre, NODE *pLoc, int *dataOut);static int _search(LIST *pList, NODE **pPre, NODE **pLoc, int argu);/* Allocates dynamic memory for a list head node and returns its address to caller	return	head node pointer			NULL if overflow*/LIST *createList(void) {	LIST* list = (LIST*)malloc(sizeof(LIST));	if (!list)		return NULL;	list->count = 0;	list->pos = NULL;	list->head = NULL;	list->rear = NULL;	return list;};/* Deletes all data in list and recycles memory	return	NULL head pointer*/LIST *destroyList(LIST *pList) {	while(1) {		pList->pos = pList->head;		for (int i = 1; i < pList->count - 1; i++) {			pList->pos = pList->pos->link;           // move to preNode of lastNode		}		if (pList->count > 1) {			free(pList->rear);			pList->pos->link = NULL;			pList->rear = pList->pos;			pList->count--;		}		else if (pList->count == 1) {			free(pList->rear);			pList->rear = NULL;			pList->head = NULL;			pList->count = 0;			break;                     //complete remove all Node		}	}	free(pList);	return NULL;}/* Inserts data into list	return	-1 if overflow			0 if successful			1 if dupe key*/int addNode(LIST *pList, int dataIn) {	// LIST is empty	if (pList->count == 0) {		if (_insert(pList, pList->head, dataIn))			return 0;		else            //overflow			return -1;	}	pList->pos = pList->head;	// Head must be changed	if (pList->pos->data > dataIn) {		if (_insert(pList, pList->pos, dataIn))			return 0;		else             //overflow			return -1;	}		if(pList->head->data == dataIn)		return 1;		while (pList->pos->link->data <= dataIn) {				pList->pos = pList->pos->link;				if(pList->pos->link == NULL)			break;	}		if(pList->pos->data == dataIn)		return 1;		if (_insert(pList, pList->pos, dataIn))		return 0;	else                //overflow		return -1;	}/* Removes data from list	return	0 not found			1 deleted*/int removeNode(LIST *pList, int Key, int *dataOut) {		if (pList->count == 0) {     //List does not have any Node		return 0;	}	pList->pos = pList->head;    //List has at least one Node	int found = _search(pList, &pList->pos, &pList->pos->link, Key);	if (found) {		if (pList->count == 1 || pList->head->data == Key) {        //remove Head Node			_delete(pList, pList->pos, pList->pos, dataOut);			return 1;		}		else {			_delete(pList, pList->pos, pList->pos->link, dataOut);			return 1;		}	}	else		return 0;}/* interface to search function	Argu	key being sought	dataOut	contains found data	return	1 successful			0 not found*/int searchList(LIST *pList, int Argu, int *dataOut) {	if (_search(pList, &pList->pos, &pList->pos->link, Argu)) {		*dataOut = Argu;		return 1;	}	else		return 0;}/* returns number of nodes in list*/int listCount(LIST *pList) {	return pList->count;}/* returns	1 empty			0 list has data*/int emptyList(LIST *pList) {	if (pList->count == 0)		return 1;	else		return 0;}//int fullList( LIST *pList);/* prints data from list*/void printList(LIST *pList) {	pList->pos = pList->head;	while (pList->pos != NULL) {		printf("%d->", pList->pos->data);		pList->pos = pList->pos->link;	}	printf("NULL\n");}/* internal insert function	inserts data into a new node	return	1 if successful			0 if memory overflow*/static int _insert(LIST *pList, NODE *pPre, int dataIn) {	NODE* newNode = (NODE*)malloc(sizeof(NODE));	if (newNode == NULL)  //overflow		return 0;	newNode->data = dataIn;	if (pList->count == 0) {                      //List is empty		newNode->link = NULL;		pList->head = newNode;	}	else {		if (newNode->data < pList->head->data) {  //Head must be changed			newNode->link = pList->head;			pList->head = newNode;		}		else {			newNode->link = pPre->link;           			pPre->link = newNode;		}	}	if (newNode->link == NULL)     //newNode is Last Node		pList->rear = newNode;     //So, rear is newNode	pList->count++;	return 1;}/* internal delete function	deletes data from a list and saves the (deleted) data to dataOut*/static void _delete(LIST *pList, NODE *pPre, NODE *pLoc, int *dataOut) {			if (pPre == pLoc) {				  //remove head Node		if (pList->count == 1) {			free(pLoc);			pList->head = NULL;			pList->rear = NULL;			pList->count--;		}		else {			pList->head = pLoc->link;			free(pLoc);			pList->count--;		}	}	else {		pPre->link = pLoc->link;		*dataOut = pLoc->data;		free(pLoc);		pList->count--;		if (pPre->link == NULL) {			pList->rear = pPre;		}	}}/* internal search function	searches list and passes back address of node	containing target and its logical predecessor	return	1 found			0 not found*/static int _search(LIST *pList, NODE **pPre, NODE **pLoc, int argu) {	if (pList->count == 0)				 //List is empty		return 0;	if (pList->count == 1) {			 //List has one Node		if (pList->head->data == argu) {			*pPre = pList->head;			*pLoc = pList->head;			return 1;		}		else			return 0;	}	//List has at least two Nodes	pList->pos = pList->head;	while (pList->pos->link != NULL) {		if (pList->pos->data < argu) {			if (pList->pos->link->data > argu)				return 0;			else if (pList->pos->link->data == argu) {				pPre = &pList->pos;				pLoc = &pList->pos->link;				return 1;			}			pList->pos = pList->pos->link;		}		else if (pList->pos->data == argu) {			return 1;		}	}	return 0;}/* gets user's input*/int get_action(){	char ch;	scanf("%c", &ch);	ch = toupper(ch);	switch (ch)	{	case 'Q':		return QUIT;	case 'P':		return PRINT;	case 'I':		return INSERT;	case 'D':		return DELETE;	case 'S':		return SEARCH;	}	return 0; // undefined action}////////////////////////////////////////////////////////////////////////////////int main(void){	int num;	LIST *list;	int data;	// creates a null list	list = createList();	if (!list){	printf( "Cannot create list\n");	return 100;	}	fprintf(stdout, "Select Q)uit, P)rint, I)nsert, D)elete, or S)earch: ");	while (1)	{		int action = get_action();		switch (action)		{		case QUIT:			destroyList(list);			return 0;		case PRINT:			// print function call			printList(list);			break;		case INSERT:			fprintf(stdout, "Enter a number to insert: ");			fscanf(stdin, "%d", &num);			// insert function call			addNode(list, num);			// print function call			printList(list);			break;		case DELETE:			fprintf(stdout, "Enter a number to delete: ");			fscanf(stdin, "%d", &num);			// delete function call			removeNode( list, num, &data);			// print function call			printList(list);			break;		case SEARCH:			fprintf(stdout, "Enter a number to retrieve: ");			fscanf(stdin, "%d", &num);			// search function call			int found;			found = searchList( list, num, &data);			if (found) 				fprintf( stdout, "Found: %d\n", data);			else 				fprintf( stdout, "Not found: %d\n", num);			break;		}		if (action) fprintf(stdout, "Select Q)uit, P)rint, I)nsert, D)elete, or S)earch: ");	}	return 0;}